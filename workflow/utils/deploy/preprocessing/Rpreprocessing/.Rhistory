} else {
if (isTRUE(mode == "STARsolo")) {
write_log(paste0("Running ", mode, "for ", sample, " : ", pipeline), log_file)
result <- processx::run(cmd_base, unlist(cmd_args), error_on_status = TRUE)
write_log(paste0(mode, " completed for ", sample, " . Output: ", sample_out), log_file)
return(result)
} else if (isTRUE(mode == "STAR")) {
write_log(paste0("Running ", mode, "for ", sample, " : ", pipeline), log_file)
result <- processx::run(cmd_base, unlist(cmd_args), error_on_status = TRUE)
write_log(paste0(mode, " completed for ", sample, " . Output: ", sample_out), log_file)
return(result)
}
}
},
error = function(e) {
write_log(paste0("ERROR: ", mode, " failed for: ", sample, result$stderr))
cat("ERROR MESSAGE", mode, "failed for:", sample, e$message)
return(NULL)
}
)
}
}
pkg_wd <- getwd()
script_path <- file.path(pkg_wd, "R", "run_star_solo_unified.R")
if (!file.exists(script_path)) {
pkg_wd <- normalizePath(file.path(pkg_wd, "..", "..", "..", "..", ".."), mustWork = TRUE)
script_path <- file.path(pkg_wd, "R", "run_star_solo_unified.R")
}
source(file.path(pkg_wd, "R", "add_log_message.R"))
source(script_path)
create_temp_log <- function() {
log_file <- tempfile("preprocessing_", fileext = ".log")
file.create(log_file)
log_file
}
define_configuration <- function(mode, platform = "microwell", params = list()) {
temp_root <- tempdir()
list(
platform = platform,
input_dir = "inputs",
genome_dir = file.path(temp_root, "genome_index"),
threads = 2,
Fastq_file_format = "merged",
STAR_outdir = file.path(temp_root, "star"),
STAR_out = "output",
STAR_params = params,
STARsolo_outdir = file.path(temp_root, "starsolo"),
STARsolo_out = "solo_output",
STARsolo_params = params,
mode = mode
)
}
setup_globals <- function(configuration, samples_list, tag_values) {
assign("file", configuration, envir = globalenv())
assign("samples", samples_list, envir = globalenv())
assign("tags", tag_values, envir = globalenv())
assign("mode", configuration$mode, envir = globalenv())
}
build_output_dir <- function(base_dir, input_dir, suffix) {
output_dir <- paste0(base_dir, input_dir, suffix, sep = "/")
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
output_dir
}
test_that("run_STAR_unified builds STAR command for microwell data", {
configuration <- define_configuration(
mode = "STAR",
platform = "microwell",
params = list(outSAMtype = "BAM SortedByCoordinate")
)
samples_list <- list(Sample1 = c("Sample1_R1.fastq", "Sample1_R2.fastq"))
tag_values <- c("R1", "R2")
output_dir <- build_output_dir(configuration$STAR_outdir, configuration$input_dir, configuration$STAR_out)
log_file <- create_temp_log()
on.exit(unlink(c(log_file, output_dir), recursive = TRUE, force = TRUE), add = TRUE)
setup_globals(configuration, samples_list, tag_values)
calls <- list()
mock_run <- function(command, args, error_on_status) {
calls <<- append(calls, list(list(command = command, args = args)))
mocked_result
}
stub(run_STAR_solo_unified, "processx::run", mock_run)
result <- run_STAR_solo_unified(configuration, log_file, solo = FALSE)
expect_equal(length(calls), 1)
expect_identical(calls[[1]]$command, "STAR")
expect_true(any(grepl("--runThreadN", calls[[1]]$args)))
expect_true(any(grepl(configuration$genome_dir, calls[[1]]$args)))
expect_true(any(grepl("Sample1_R1.fastq", calls[[1]]$args)))
expect_true(any(grepl("--outSAMtype", calls[[1]]$args)))
expect_equal(result, mocked_result)
expect_true(dir.exists(file.path(output_dir, "Sample1")))
})
library("test_that")
install.packages("test_that")
install.packages("testthat")
library("testthat")
pkg_wd <- getwd()
script_path <- file.path(pkg_wd, "R", "run_star_solo_unified.R")
if (!file.exists(script_path)) {
pkg_wd <- normalizePath(file.path(pkg_wd, "..", "..", "..", "..", ".."), mustWork = TRUE)
script_path <- file.path(pkg_wd, "R", "run_star_solo_unified.R")
}
source(file.path(pkg_wd, "R", "add_log_message.R"))
source(script_path)
create_temp_log <- function() {
log_file <- tempfile("preprocessing_", fileext = ".log")
file.create(log_file)
log_file
}
define_configuration <- function(mode, platform = "microwell", params = list()) {
temp_root <- tempdir()
list(
platform = platform,
input_dir = "inputs",
genome_dir = file.path(temp_root, "genome_index"),
threads = 2,
Fastq_file_format = "merged",
STAR_outdir = file.path(temp_root, "star"),
STAR_out = "output",
STAR_params = params,
STARsolo_outdir = file.path(temp_root, "starsolo"),
STARsolo_out = "solo_output",
STARsolo_params = params,
mode = mode
)
}
setup_globals <- function(configuration, samples_list, tag_values) {
assign("file", configuration, envir = globalenv())
assign("samples", samples_list, envir = globalenv())
assign("tags", tag_values, envir = globalenv())
assign("mode", configuration$mode, envir = globalenv())
}
build_output_dir <- function(base_dir, input_dir, suffix) {
output_dir <- paste0(base_dir, input_dir, suffix, sep = "/")
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
output_dir
}
test_that("run_STAR_unified builds STAR command for microwell data", {
configuration <- define_configuration(
mode = "STAR",
platform = "microwell",
params = list(outSAMtype = "BAM SortedByCoordinate")
)
samples_list <- list(Sample1 = c("Sample1_R1.fastq", "Sample1_R2.fastq"))
tag_values <- c("R1", "R2")
output_dir <- build_output_dir(configuration$STAR_outdir, configuration$input_dir, configuration$STAR_out)
log_file <- create_temp_log()
on.exit(unlink(c(log_file, output_dir), recursive = TRUE, force = TRUE), add = TRUE)
setup_globals(configuration, samples_list, tag_values)
calls <- list()
mock_run <- function(command, args, error_on_status) {
calls <<- append(calls, list(list(command = command, args = args)))
mocked_result
}
stub(run_STAR_solo_unified, "processx::run", mock_run)
result <- run_STAR_solo_unified(configuration, log_file, solo = FALSE)
expect_equal(length(calls), 1)
expect_identical(calls[[1]]$command, "STAR")
expect_true(any(grepl("--runThreadN", calls[[1]]$args)))
expect_true(any(grepl(configuration$genome_dir, calls[[1]]$args)))
expect_true(any(grepl("Sample1_R1.fastq", calls[[1]]$args)))
expect_true(any(grepl("--outSAMtype", calls[[1]]$args)))
expect_equal(result, mocked_result)
expect_true(dir.exists(file.path(output_dir, "Sample1")))
})
?stub
??stub
source("./R/preparing_start_genome.R")
source("./R/add_log_message.R")
#' Helper: create minimal genome and splice junction parameter lists for testing
minimal_genome_index_params <- function() {
list(
genomeChrBinNbits = 18,
genomeSAindexNbases = 12,
genomeSAsparseD = 1,
genomeSuffixLengthMax = 0,
genomeTransformType = NULL,
genomeTransformVCF = tempfile("vcf")
)
}
minimal_splice_junction_params <- function(tmp_dir) {
list(
sjdbGTFfile = file.path(tmp_dir, "annotation.gtf"),
sjdbOverhang = 100,
sjdbFileChrStartEnd = file.path(tmp_dir, "sjdb.tsv"),
sjdbGTFchrPrefix = "",
sjdbGTFfeatureExon = "exon",
sjdbGTFtagExonParentTranscript = "transcript_id",
sjdbGTFtagExonParentGene = "gene_id",
sjdbGTFtagExonParentGeneName = "gene_name",
sjdbGTFtagExonParentGeneType = "gene_type",
sjdbScore = 2,
sjdbInsertSave = "Basic"
)
}
test_that("prepare_STAR_genome exits early when index exists", {
tmp_dir <- tempdir()
genome_dir <- file.path(tmp_dir, "existing_genome")
dir.create(genome_dir, showWarnings = FALSE)
file.create(file.path(genome_dir, "Genome"))
file.create(file.path(genome_dir, "SA"))
file.create(file.path(genome_dir, "SAIndex"))
log_file <- tempfile("preprocessing", tmpdir = tmp_dir, fileext = ".log")
withr::local_file(log_file)
result <- prepare_STAR_genome(
genome_dir,
fasta_file = file.path(tmp_dir, "genome.fa"),
genome_index_params = minimal_genome_index_params(),
splice_junction_params = minimal_splice_junction_params(tmp_dir),
log_file = log_file
)
expect_null(result)
log_lines <- readLines(log_file)
expect_true(any(grepl("already exists", log_lines)))
})
test_that("prepare_STAR_genome builds and runs STAR command when index is missing", {
tmp_dir <- tempdir()
genome_dir <- file.path(tmp_dir, "new_genome")
if (dir.exists(genome_dir)) unlink(genome_dir, recursive = TRUE)
log_file <- tempfile("preprocessing", tmpdir = tmp_dir, fileext = ".log")
withr::local_file(log_file)
captured_args <- list()
mock_run <- function(command, args, error_on_status) {
captured_args$command <<- command
captured_args$args <<- args
captured_args$error_on_status <<- error_on_status
list(status = 0, stdout = "mocked")
}
# Save original
original_run <- get("run", envir = asNamespace("processx"))
# Patch run() in processx namespace
assignInNamespace("run", mock_run, ns = "processx")
# Ensure restoration even if test fails
withr::defer(assignInNamespace("run", original_run, ns = "processx"))
params_genome <- minimal_genome_index_params()
params_splice <- minimal_splice_junction_params(tmp_dir)
result <- prepare_STAR_genome(
genome_dir,
fasta_file = file.path(tmp_dir, "genome.fa"),
genome_index_params = params_genome,
splice_junction_params = params_splice,
log_file = log_file
)
expect_true(dir.exists(genome_dir))
expect_equal(result$status, 0)
expect_equal(captured_args$command, "STAR")
expect_true(any(grepl("--runMode", captured_args$args)))
expect_true(any(grepl("--genomeDir", captured_args$args)))
expect_true(any(grepl("--sjdbGTFfile", captured_args$args)))
log_lines <- readLines(log_file)
expect_true(any(grepl("Running STAR command", log_lines)))
expect_true(any(grepl("genome index generated", log_lines)))
})
# install.packages("mockery")  # once
mockery::stub(run_STAR_solo_unified, "processx::run", mock_run)
install.packages("mockery")
library("mockery")
pkg_wd <- getwd()
script_path <- file.path(pkg_wd, "R", "run_star_solo_unified.R")
if (!file.exists(script_path)) {
pkg_wd <- normalizePath(file.path(pkg_wd, "..", "..", "..", "..", ".."), mustWork = TRUE)
script_path <- file.path(pkg_wd, "R", "run_star_solo_unified.R")
}
source(file.path(pkg_wd, "R", "add_log_message.R"))
source(script_path)
create_temp_log <- function() {
log_file <- tempfile("preprocessing_", fileext = ".log")
file.create(log_file)
log_file
}
define_configuration <- function(mode, platform = "microwell", params = list()) {
temp_root <- tempdir()
list(
platform = platform,
input_dir = "inputs",
genome_dir = file.path(temp_root, "genome_index"),
threads = 2,
Fastq_file_format = "merged",
STAR_outdir = file.path(temp_root, "star"),
STAR_out = "output",
STAR_params = params,
STARsolo_outdir = file.path(temp_root, "starsolo"),
STARsolo_out = "solo_output",
STARsolo_params = params,
mode = mode
)
}
setup_globals <- function(configuration, samples_list, tag_values) {
assign("file", configuration, envir = globalenv())
assign("samples", samples_list, envir = globalenv())
assign("tags", tag_values, envir = globalenv())
assign("mode", configuration$mode, envir = globalenv())
}
build_output_dir <- function(base_dir, input_dir, suffix) {
output_dir <- paste0(base_dir, input_dir, suffix, sep = "/")
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
output_dir
}
test_that("run_STAR_unified builds STAR command for microwell data", {
configuration <- define_configuration(
mode = "STAR",
platform = "microwell",
params = list(outSAMtype = "BAM SortedByCoordinate")
)
samples_list <- list(Sample1 = c("Sample1_R1.fastq", "Sample1_R2.fastq"))
tag_values <- c("R1", "R2")
output_dir <- build_output_dir(configuration$STAR_outdir, configuration$input_dir, configuration$STAR_out)
log_file <- create_temp_log()
on.exit(unlink(c(log_file, output_dir), recursive = TRUE, force = TRUE), add = TRUE)
setup_globals(configuration, samples_list, tag_values)
calls <- list()
mock_run <- function(command, args, error_on_status) {
calls <<- append(calls, list(list(command = command, args = args)))
mocked_result
}
stub(run_STAR_solo_unified, "processx::run", mock_run)
result <- run_STAR_solo_unified(configuration, log_file, solo = FALSE)
expect_equal(length(calls), 1)
expect_identical(calls[[1]]$command, "STAR")
expect_true(any(grepl("--runThreadN", calls[[1]]$args)))
expect_true(any(grepl(configuration$genome_dir, calls[[1]]$args)))
expect_true(any(grepl("Sample1_R1.fastq", calls[[1]]$args)))
expect_true(any(grepl("--outSAMtype", calls[[1]]$args)))
expect_equal(result, mocked_result)
expect_true(dir.exists(file.path(output_dir, "Sample1")))
})
library("styler")
install.packages("styler")
library("styler")
pkg_wd <- getwd()
script_path <- file.path(pkg_wd, "R", "run_star_solo_unified.R")
if (!file.exists(script_path)) {
pkg_wd <- normalizePath(file.path(pkg_wd, "..", "..", "..", "..", ".."), mustWork = TRUE)
script_path <- file.path(pkg_wd, "R", "run_star_solo_unified.R")
}
source(file.path(pkg_wd, "R", "add_log_message.R"))
source(script_path)
test_that("run_STAR_unified builds STAR command for microwell data", {
testthat::skip_if_not_installed("mockery")
configuration <- define_configuration(
mode = "STAR",
platform = "microwell",
params = list(outSAMtype = "BAM SortedByCoordinate")
)
samples_list <- list(Sample1 = c("Sample1_R1.fastq", "Sample1_R2.fastq"))
tag_values <- c("R1", "R2")
output_dir <- build_output_dir(configuration$STAR_outdir, configuration$input_dir, configuration$STAR_out)
log_file <- create_temp_log()
on.exit(unlink(c(log_file, output_dir), recursive = TRUE, force = TRUE), add = TRUE)
# Function relies on globals: file, samples, tags, mode, AND (when solo=FALSE) output_dir + params
setup_globals(configuration, samples_list, tag_values)
assign("output_dir", output_dir, envir = globalenv())
assign("params", configuration$STAR_params, envir = globalenv())
# Clean up globals so tests don't leak into each other
on.exit(
rm(list = intersect(c("file", "samples", "tags", "mode", "output_dir", "params"),
ls(envir = globalenv())),
envir = globalenv()),
add = TRUE
)
calls <- list()
mocked_result <- list(status = 0, stdout = "", stderr = "")
mock_run <- function(command, args, error_on_status) {
calls <<- append(calls, list(list(command = command, args = args, error_on_status = error_on_status)))
mocked_result
}
mockery::stub(run_STAR_solo_unified, "processx::run", mock_run)
result <- run_STAR_solo_unified(configuration, log_file, solo = FALSE)
expect_equal(length(calls), 1)
expect_identical(calls[[1]]$command, "STAR")
expect_true(any(grepl("--runThreadN", calls[[1]]$args)))
expect_true(any(grepl(configuration$genome_dir, calls[[1]]$args)))
expect_true(any(grepl("Sample1_R1.fastq", calls[[1]]$args)))
expect_true(any(grepl("Sample1_R2.fastq", calls[[1]]$args)))
# Params are currently reflected in the *logged pipeline* (not in processx::run args)
log_entries <- readLines(log_file, warn = FALSE)
expect_true(any(grepl("--outSAMtype", log_entries)))
expect_equal(result, mocked_result)
expect_true(dir.exists(file.path(output_dir, "Sample1")))
})
source("./R/preparing_start_genome.R")
source("./R/add_log_message.R")
test_that("run_STAR_unified builds STAR command for microwell data", {
testthat::skip_if_not_installed("mockery")
configuration <- define_configuration(
mode = "STAR",
platform = "microwell",
params = list(outSAMtype = "BAM SortedByCoordinate")
)
samples_list <- list(Sample1 = c("Sample1_R1.fastq", "Sample1_R2.fastq"))
tag_values <- c("R1", "R2")
output_dir <- build_output_dir(configuration$STAR_outdir, configuration$input_dir, configuration$STAR_out)
log_file <- create_temp_log()
on.exit(unlink(c(log_file, output_dir), recursive = TRUE, force = TRUE), add = TRUE)
# Function relies on globals: file, samples, tags, mode, AND (when solo=FALSE) output_dir + params
setup_globals(configuration, samples_list, tag_values)
assign("output_dir", output_dir, envir = globalenv())
assign("params", configuration$STAR_params, envir = globalenv())
# Clean up globals so tests don't leak into each other
on.exit(
rm(list = intersect(c("file", "samples", "tags", "mode", "output_dir", "params"),
ls(envir = globalenv())),
envir = globalenv()),
add = TRUE
)
calls <- list()
mocked_result <- list(status = 0, stdout = "", stderr = "")
mock_run <- function(command, args, error_on_status) {
calls <<- append(calls, list(list(command = command, args = args, error_on_status = error_on_status)))
mocked_result
}
mockery::stub(run_STAR_solo_unified, "processx::run", mock_run)
result <- run_STAR_solo_unified(configuration, log_file, solo = FALSE)
expect_equal(length(calls), 1)
expect_identical(calls[[1]]$command, "STAR")
expect_true(any(grepl("--runThreadN", calls[[1]]$args)))
expect_true(any(grepl(configuration$genome_dir, calls[[1]]$args)))
expect_true(any(grepl("Sample1_R1.fastq", calls[[1]]$args)))
expect_true(any(grepl("Sample1_R2.fastq", calls[[1]]$args)))
# Params are currently reflected in the *logged pipeline* (not in processx::run args)
log_entries <- readLines(log_file, warn = FALSE)
expect_true(any(grepl("--outSAMtype", log_entries)))
expect_equal(result, mocked_result)
expect_true(dir.exists(file.path(output_dir, "Sample1")))
})
source("./R/preparing_start_genome.R")
source("./R/add_log_message.R")
test_that("run_STAR_unified builds STAR command for microwell data", {
testthat::skip_if_not_installed("mockery")
configuration <- define_configuration(
mode = "STAR",
platform = "microwell",
params = list(outSAMtype = "BAM SortedByCoordinate")
)
samples_list <- list(Sample1 = c("Sample1_R1.fastq", "Sample1_R2.fastq"))
tag_values <- c("R1", "R2")
output_dir <- build_output_dir(configuration$STAR_outdir, configuration$input_dir, configuration$STAR_out)
log_file <- create_temp_log()
on.exit(unlink(c(log_file, output_dir), recursive = TRUE, force = TRUE), add = TRUE)
# Function relies on globals: file, samples, tags, mode, AND (when solo=FALSE) output_dir + params
setup_globals(configuration, samples_list, tag_values)
assign("output_dir", output_dir, envir = globalenv())
assign("params", configuration$STAR_params, envir = globalenv())
# Clean up globals so tests don't leak into each other
on.exit(
rm(list = intersect(c("file", "samples", "tags", "mode", "output_dir", "params"),
ls(envir = globalenv())),
envir = globalenv()),
add = TRUE
)
calls <- list()
mocked_result <- list(status = 0, stdout = "", stderr = "")
mock_run <- function(command, args, error_on_status) {
calls <<- append(calls, list(list(command = command, args = args, error_on_status = error_on_status)))
mocked_result
}
mockery::stub(run_STAR_solo_unified, "processx::run", mock_run)
result <- run_STAR_solo_unified(configuration, log_file, solo = FALSE)
expect_equal(length(calls), 1)
expect_identical(calls[[1]]$command, "STAR")
expect_true(any(grepl("--runThreadN", calls[[1]]$args)))
expect_true(any(grepl(configuration$genome_dir, calls[[1]]$args, fixed = TRUE)))
expect_true(any(grepl("Sample1_R1.fastq", calls[[1]]$args)))
expect_true(any(grepl("Sample1_R2.fastq", calls[[1]]$args)))
# Params are currently reflected in the *logged pipeline* (not in processx::run args)
log_entries <- readLines(log_file, warn = FALSE)
expect_true(any(grepl("--outSAMtype", log_entries)))
expect_equal(result, mocked_result)
expect_true(dir.exists(file.path(output_dir, "Sample1")))
})
test_that("run_STAR_unified logs and uses droplet settings when solo is requested", {
testthat::skip_if_not_installed("mockery")
configuration <- define_configuration(
mode = "STARsolo",
platform = "droplet",
params = list(soloType = "CB_UMI_Simple")
)
samples_list <- list(CellA = c("CellA_R1.fastq", "CellA_R2.fastq"))
tag_values <- c("R1", "R2")
output_dir <- build_output_dir(configuration$STAR_outdir, configuration$input_dir, configuration$STAR_out)
log_file <- create_temp_log()
on.exit(unlink(c(log_file, output_dir), recursive = TRUE, force = TRUE), add = TRUE)
setup_globals(configuration, samples_list, tag_values)
on.exit(
rm(list = intersect(c("file", "samples", "tags", "mode"),
ls(envir = globalenv())),
envir = globalenv()),
add = TRUE
)
calls <- list()
mocked_result <- list(status = 0, stdout = "", stderr = "")
mock_run <- function(command, args, error_on_status) {
calls <<- append(calls, list(list(command = command, args = args, error_on_status = error_on_status)))
mocked_result
}
mockery::stub(run_STAR_solo_unified, "processx::run", mock_run)
result <- run_STAR_solo_unified(configuration, log_file, solo = TRUE)
log_entries <- readLines(log_file, warn = FALSE)
expect_true(any(grepl("Skipping STAR", log_entries)))
expect_equal(length(calls), 1)
expect_identical(calls[[1]]$command, "STAR")
# Params currently show up in the logged pipeline
expect_true(any(grepl("--soloType", log_entries)))
expect_equal(result, mocked_result)
})
?Seurat::Read10X
devtools::load_all()
devtools::load_all(".")
devtools::document()
devtools::load_all()
rm(list = c("prepare_STAR_genome"))
devtools::document()
devtools::load_all()
